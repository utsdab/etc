#!/usr/bin/env python
#!/usr/bin/env python

#
# An example python Tractor login validation script that connects
# to an ldap server for simple password validation.
#
# Copyright (C) 2011-2012 Pixar Animation Studios.
# The information in this file is provided for the exclusive use of the
# licensees of Pixar.  Such users have the right to use, modify, and
# incorporate this code into other products for purposes authorized
# by the Pixar license agreement, without fee.
#
# PIXAR DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
# ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT
# SHALL PIXAR BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES
# OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
# WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
# ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
# SOFTWARE.
#

import sys
import ldap

## ------------------------------------------------------------- ##

def main ():

    # This routine expects to receive a userid, challenge, and
    # password on stdin as newline-separated strings:
    # like  "yoda\n12345 abcd\nPW\n"
    #
    # In realistic use the inbound "password" will actually be a
    # site-defined hash of the real password and the challenge.
    #
    # When a Tractor Dashboard session or tq script begin a transaction
    # with the Engine they receive a login mode and potentially a
    # one-time random challenge string, generated by the Engine.
    # Login handling that is NOT using the "PAM" support scheme
    # requires each studio to implement two halves of the password
    # handling mechanism, one on the Engine side (such as this script)
    # and one in the client(s) - such as in trSiteDashboardFuntions.js
    # for the Dashboard.  The details are very dependent on the
    # specific way that passwords are stored at each studio.
    # Some studios may send an custom encoding of the password
    # which might be decoded here are tested directly, such as
    # with the simple "bind" below or something more sophisticated.
    #
    # A more secure approach is for the client to hash the challenge
    # string with the user-supplied password in the client app itself,
    # then the client sends that hash, not the password. The password
    # cannot be recovered from the hash, even if that is intercepted
    # in transit. Handlers like this one on Engine would then validate
    # the hash. The inbound challenge string here is sent from the
    # engine, it is the same one that it sent to the client earlier.
    # So one approach is to look up the given user's password here
    # hash it with the challenge and compare that to the "password"
    # string sent from the client (i.e. the hash it computed). If
    # cleartext passwords are not stored locally (typical) then the code
    # here might retrieve a previously "crypted" hash of the password
    # instead, hashing that a second time with the challange string. In
    # this scenario the client app handlers (for Dashboard, tq) would
    # first apply the same "crypt" as used by the site password storage
    # scheme, then hash again with the challenge and send that result.
    #

    user = raw_input()
    challenge = raw_input()
    pw_hash = raw_input()

    domain = "local" # eg myhost.local, user your ldap domain

    serveruri="ldap://ldap.%s" % domain
    ldsrvr = ldap.initialize(serveruri)

    who = "uid=%s,ou=people,o=%s" % (user, domain)
    cred = pw_hash.strip()
    rc = 0

    try:
        # in this example, simply attempting the bind is password validation
        ldsrvr.bind_s(who, cred)
    except ldap.LDAPError, error_message:
        # handle the specific error here, or perhaps try again if there
        # are several scopes that might apply
        who = "uid=%s,ou=sysaccounts,o=%s" % (user, domain)
        try:
            ldsrvr.bind_s(who, cred)
        except ldap.LDAPError, error_message:
            rc = 1

    del(ldsrvr)
    return rc

## ------------------------------------------------------------- ##

if __name__ == "__main__":

    rc = main()

    if 0 != rc:
        sys.exit(rc)
